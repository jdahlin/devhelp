<HTML
><HEAD
><TITLE
>Class GtkWidget</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.54"><LINK
REL="HOME"
TITLE="PyGTK Docs"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Class GtkViewport"
HREF="class-gtkviewport.html"><LINK
REL="NEXT"
TITLE="Class GtkWindow"
HREF="class-gtkwindow.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PyGTK Docs</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="class-gtkviewport.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="class-gtkwindow.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CLASS-GTKWIDGET"
>Class GtkWidget</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN24943"
>Ancestry</A
></H2
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>+-- GObject
  +-- <A
HREF="class-gtkobject.html"
>GtkObject</A
>
    +-- <A
HREF="class-gtkwidget.html"
>GtkWidget</A
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN24949"
>Methods</A
></H2
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-ALLOCATION"
>GtkWidget.get_allocation</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_allocation</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>a GtkAllocation</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-GET-DATA"
>GtkWidget.drag_get_data</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_get_data</B
></CODE
>(<VAR
CLASS="PDPARAM"
>context</VAR
>, <VAR
CLASS="PDPARAM"
>target</VAR
>, <VAR
CLASS="PDPARAM"
>time</VAR
>=GDK_CURRENT_TIME);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>context</I
></TT
></DT
><DD
><P
>a GdkDragContext*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>target</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>time</I
></TT
></DT
><DD
><P
>a guint32</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-HIGHLIGHT"
>GtkWidget.drag_highlight</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_highlight</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-UNHIGHLIGHT"
>GtkWidget.drag_unhighlight</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_unhighlight</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-DEST-SET"
>GtkWidget.drag_dest_set</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_dest_set</B
></CODE
>(<VAR
CLASS="PDPARAM"
>flags</VAR
>, <VAR
CLASS="PDPARAM"
>targets</VAR
>, <VAR
CLASS="PDPARAM"
>n_targets</VAR
>, <VAR
CLASS="PDPARAM"
>actions</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
></DT
><DD
><P
>a GtkDestDefaults</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>targets</I
></TT
></DT
><DD
><P
>a const-GtkTargetEntry*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>n_targets</I
></TT
></DT
><DD
><P
>a gint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>actions</I
></TT
></DT
><DD
><P
>a GdkDragAction</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-DEST-SET-PROXY"
>GtkWidget.drag_dest_set_proxy</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_dest_set_proxy</B
></CODE
>(<VAR
CLASS="PDPARAM"
>proxy_window</VAR
>, <VAR
CLASS="PDPARAM"
>protocol</VAR
>, <VAR
CLASS="PDPARAM"
>use_coordinates</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>proxy_window</I
></TT
></DT
><DD
><P
>a GdkWindow*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>protocol</I
></TT
></DT
><DD
><P
>a GdkDragProtocol</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>use_coordinates</I
></TT
></DT
><DD
><P
>a gboolean</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-DEST-UNSET"
>GtkWidget.drag_dest_unset</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_dest_unset</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-DEST-FIND-TARGET"
>GtkWidget.drag_dest_find_target</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_dest_find_target</B
></CODE
>(<VAR
CLASS="PDPARAM"
>context</VAR
>, <VAR
CLASS="PDPARAM"
>target_list</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>context</I
></TT
></DT
><DD
><P
>drag context</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>target_list</I
></TT
></DT
><DD
><P
>list of droppable targets</P
></DD
><DT
>Returns:</DT
><DD
><P
>first target that the source offers and the dest can accept, or <TT
CLASS="LITERAL"
>GDK_NONE</TT
></P
></DD
></DL
></DIV
><P
>Looks for a match between <TT
CLASS="PARAMETER"
><I
>context</I
></TT
>-&#62;targets and the
<TT
CLASS="PARAMETER"
><I
>dest_target_list</I
></TT
>, returning the first matching target, otherwise
returning <TT
CLASS="LITERAL"
>GDK_NONE</TT
>. <TT
CLASS="PARAMETER"
><I
>dest_target_list</I
></TT
> should usually be the return
value from <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--DRAG-DEST-GET-TARGET-LIST"
><TT
CLASS="FUNCTION"
>GtkWidget.drag_dest_get_target_list()</TT
></A
>, but some widgets may
have different valid targets for different parts of the widget; in
that case, they will have to implement a drag_motion handler that
passes the correct target list to this function.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-DEST-GET-TARGET-LIST"
>GtkWidget.drag_dest_get_target_list</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_dest_get_target_list</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the <TT
CLASS="LITERAL"
>GtkTargetList</TT
>, or <TT
CLASS="LITERAL"
>NULL</TT
> if none</P
></DD
></DL
></DIV
><P
>Returns the list of targets this widget can accept from
drag-and-drop.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-DEST-SET-TARGET-LIST"
>GtkWidget.drag_dest_set_target_list</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_dest_set_target_list</B
></CODE
>(<VAR
CLASS="PDPARAM"
>target_list</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>target_list</I
></TT
></DT
><DD
><P
>list of droppable targets, or <TT
CLASS="LITERAL"
>NULL</TT
> for none</P
></DD
></DL
></DIV
><P
>Sets the target types that this widget can accept from drag-and-drop.
The widget must first be made into a drag destination with
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--DRAG-DEST-SET"
><TT
CLASS="FUNCTION"
>GtkWidget.drag_dest_set()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-SOURCE-SET"
>GtkWidget.drag_source_set</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_source_set</B
></CODE
>(<VAR
CLASS="PDPARAM"
>start_button_mask</VAR
>, <VAR
CLASS="PDPARAM"
>targets</VAR
>, <VAR
CLASS="PDPARAM"
>n_targets</VAR
>, <VAR
CLASS="PDPARAM"
>actions</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>start_button_mask</I
></TT
></DT
><DD
><P
>a GdkModifierType</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>targets</I
></TT
></DT
><DD
><P
>a const-GtkTargetEntry*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>n_targets</I
></TT
></DT
><DD
><P
>a gint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>actions</I
></TT
></DT
><DD
><P
>a GdkDragAction</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-SOURCE-UNSET"
>GtkWidget.drag_source_unset</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_source_unset</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-SOURCE-SET-ICON"
>GtkWidget.drag_source_set_icon</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_source_set_icon</B
></CODE
>(<VAR
CLASS="PDPARAM"
>colormap</VAR
>, <VAR
CLASS="PDPARAM"
>pixmap</VAR
>, <VAR
CLASS="PDPARAM"
>mask</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>colormap</I
></TT
></DT
><DD
><P
>a GdkColormap*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>pixmap</I
></TT
></DT
><DD
><P
>a GdkPixmap*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>mask</I
></TT
></DT
><DD
><P
>a GdkBitmap*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAG-BEGIN"
>GtkWidget.drag_begin</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>drag_begin</B
></CODE
>(<VAR
CLASS="PDPARAM"
>targets</VAR
>, <VAR
CLASS="PDPARAM"
>actions</VAR
>, <VAR
CLASS="PDPARAM"
>button</VAR
>, <VAR
CLASS="PDPARAM"
>event</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>targets</I
></TT
></DT
><DD
><P
>a GtkTargetList*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>actions</I
></TT
></DT
><DD
><P
>a GdkDragAction</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>button</I
></TT
></DT
><DD
><P
>a gint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>event</I
></TT
></DT
><DD
><P
>a GdkEvent*</P
></DD
><DT
>Returns:</DT
><DD
><P
>a GdkDragContext*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GRAB-ADD"
>GtkWidget.grab_add</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>grab_add</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GRAB-REMOVE"
>GtkWidget.grab_remove</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>grab_remove</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--RC-GET-STYLE"
>GtkWidget.rc_get_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>rc_get_style</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>a GtkStyle*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-OWNER-SET"
>GtkWidget.selection_owner_set</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_owner_set</B
></CODE
>(<VAR
CLASS="PDPARAM"
>selection</VAR
>, <VAR
CLASS="PDPARAM"
>time</VAR
>=GDK_CURRENT_TIME);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>selection</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>time</I
></TT
></DT
><DD
><P
>a guint32</P
></DD
><DT
>Returns:</DT
><DD
><P
>a gboolean</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-ADD-TARGET"
>GtkWidget.selection_add_target</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_add_target</B
></CODE
>(<VAR
CLASS="PDPARAM"
>selection</VAR
>, <VAR
CLASS="PDPARAM"
>target</VAR
>, <VAR
CLASS="PDPARAM"
>info</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>selection</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>target</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>info</I
></TT
></DT
><DD
><P
>a guint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-ADD-TARGETS"
>GtkWidget.selection_add_targets</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_add_targets</B
></CODE
>(<VAR
CLASS="PDPARAM"
>selection</VAR
>, <VAR
CLASS="PDPARAM"
>targets</VAR
>, <VAR
CLASS="PDPARAM"
>ntargets</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>selection</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>targets</I
></TT
></DT
><DD
><P
>a const-GtkTargetEntry*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>ntargets</I
></TT
></DT
><DD
><P
>a guint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-CLEAR-TARGETS"
>GtkWidget.selection_clear_targets</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_clear_targets</B
></CODE
>(<VAR
CLASS="PDPARAM"
>selection</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>selection</I
></TT
></DT
><DD
><P
>an atom representing a selection</P
></DD
></DL
></DIV
><P
>Remove all targets registered for the given selection for the
widget.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-CONVERT"
>GtkWidget.selection_convert</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_convert</B
></CODE
>(<VAR
CLASS="PDPARAM"
>selection</VAR
>, <VAR
CLASS="PDPARAM"
>target</VAR
>, <VAR
CLASS="PDPARAM"
>time</VAR
>=GDK_CURRENT_TIME);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>selection</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>target</I
></TT
></DT
><DD
><P
>a GdkAtom</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>time</I
></TT
></DT
><DD
><P
>a guint32</P
></DD
><DT
>Returns:</DT
><DD
><P
>a gint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-REMOVE-ALL"
>GtkWidget.selection_remove_all</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_remove_all</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SELECTION-CLEAR"
>GtkWidget.selection_clear</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>selection_clear</B
></CODE
>(<VAR
CLASS="PDPARAM"
>event</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>event</I
></TT
></DT
><DD
><P
>a GdkEventSelection*</P
></DD
><DT
>Returns:</DT
><DD
><P
>a gint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--REF"
>GtkWidget.ref</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>ref</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the widget that was referenced</P
></DD
></DL
></DIV
><P
>Adds a reference to a widget. This function is exactly the same
as calling <TT
CLASS="FUNCTION"
>g_object_ref()</TT
>, and exists mostly for historical
reasons. It can still be convenient to avoid casting a widget
to a <TT
CLASS="LITERAL"
>GObject</TT
>, it saves a small amount of typing.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--UNREF"
>GtkWidget.unref</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>unref</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Inverse of <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--REF"
><TT
CLASS="FUNCTION"
>GtkWidget.ref()</TT
></A
>. Equivalent to <TT
CLASS="FUNCTION"
>g_object_unref()</TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DESTROY"
>GtkWidget.destroy</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>destroy</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Destroys a widget. Equivalent to <A
HREF="class-gtkobject.html#METHOD-GTKOBJECT--DESTROY"
><TT
CLASS="FUNCTION"
>GtkObject.destroy()</TT
></A
>, except that
you don't have to cast the widget to <A
HREF="class-gtkobject.html"
><SPAN
CLASS="TYPE"
>GtkObject</SPAN
></A
>. When a widget is
destroyed, it will break any references it holds to other objects.
If the widget is inside a container, the widget will be removed
from the container. If the widget is a toplevel (derived from
<A
HREF="class-gtkwindow.html"
><SPAN
CLASS="TYPE"
>GtkWindow</SPAN
></A
>), it will be removed from the list of toplevels, and the
reference GTK+ holds to it will be removed. Removing a
widget from its container or the list of toplevels results in the
widget being finalized, unless you've added additional references
to the widget with <A
HREF="class-gtkobject.html#METHOD-GTKOBJECT--REF"
><TT
CLASS="FUNCTION"
>GtkObject.ref()</TT
></A
>.</P
><P
>In most cases, only toplevel widgets (windows) require explicit
destruction, because when you destroy a toplevel its children will
be destroyed as well.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DESTROYED"
>GtkWidget.destroyed</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>destroyed</B
></CODE
>(<VAR
CLASS="PDPARAM"
>widget_pointer</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>widget_pointer</I
></TT
></DT
><DD
><P
>address of a variable that contains <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>This function sets *<TT
CLASS="PARAMETER"
><I
>widget_pointer</I
></TT
> to NULL if <TT
CLASS="PARAMETER"
><I
>widget_pointer</I
></TT
> !=
NULL.  It's intended to be used as a callback connected to the
"destroy" signal of a widget. You connect <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--DESTROYED"
><TT
CLASS="FUNCTION"
>GtkWidget.destroyed()</TT
></A
>
as a signal handler, and pass the address of your widget variable
as user data. Then when the widget is destroyed, the variable will
be set to NULL. Useful for example to avoid multiple copies
of the same dialog.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--UNPARENT"
>GtkWidget.unparent</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>unparent</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>This function is only for use in widget implementations.
Should be called by implementations of the remove method
on <A
HREF="class-gtkcontainer.html"
><SPAN
CLASS="TYPE"
>GtkContainer</SPAN
></A
>, to dissociate a child from the container.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SHOW"
>GtkWidget.show</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>show</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Flags a widget to be displayed. Any widget that isn't shown will
not appear on the screen. If you want to show all the widgets in a
container, it's easier to call <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SHOW-ALL"
><TT
CLASS="FUNCTION"
>GtkWidget.show_all()</TT
></A
> on the
container, instead of individually showing the widgets.</P
><P
>Remember that you have to show the containers containing a widget,
in addition to the widget itself, before it will appear onscreen.</P
><P
>When a toplevel container is shown, it is immediately realized and
mapped; other shown widgets are realized and mapped when their
toplevel container is realized and mapped.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SHOW-NOW"
>GtkWidget.show_now</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>show_now</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Shows a widget. If the widget is an unmapped toplevel widget
(i.e. a <A
HREF="class-gtkwindow.html"
><SPAN
CLASS="TYPE"
>GtkWindow</SPAN
></A
> that has not yet been shown), enter the main
loop and wait for the window to actually be mapped. Be careful;
because the main loop is running, anything can happen during
this function.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--HIDE"
>GtkWidget.hide</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>hide</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Reverses the effects of <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SHOW"
><TT
CLASS="FUNCTION"
>GtkWidget.show()</TT
></A
>, causing the widget to be
hidden (invisible to the user).</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SHOW-ALL"
>GtkWidget.show_all</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>show_all</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Recursively shows a widget, and any child widgets (if the widget is
a container).</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--HIDE-ALL"
>GtkWidget.hide_all</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>hide_all</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Recursively hides a widget and any child widgets.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MAP"
>GtkWidget.map</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>map</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>This function is only for use in widget implementations. Causes
a widget to be mapped if it isn't already.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--UNMAP"
>GtkWidget.unmap</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>unmap</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>This function is only for use in widget implementations. Causes
a widget to be unmapped if it's currently mapped.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--REALIZE"
>GtkWidget.realize</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>realize</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Creates the GDK (windowing system) resources associated with a
widget.  For example, widget-&#62;window will be created when a widget
is realized.  Normally realization happens implicitly; if you show
a widget and all its parent containers, then the widget will be
realized and mapped automatically.</P
><P
>Realizing a widget requires all
the widget's parent widgets to be realized; calling
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--REALIZE"
><TT
CLASS="FUNCTION"
>GtkWidget.realize()</TT
></A
> realizes the widget's parents in addition to
<TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> itself. If a widget is not yet inside a toplevel window
when you realize it, bad things will happen.</P
><P
>This function is primarily used in widget implementations, and
isn't very useful otherwise. Many times when you think you might
need it, a better approach is to connect to a signal that will be
called after the widget is realized automatically, such as
"expose_event". Or simply <TT
CLASS="FUNCTION"
>gtk_signal_connect_after()</TT
> to the
"realize" signal.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--UNREALIZE"
>GtkWidget.unrealize</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>unrealize</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>This function is only useful in widget implementations.
Causes a widget to be unrealized (frees all GDK resources
associated with the widget, such as widget-&#62;window).</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--QUEUE-DRAW"
>GtkWidget.queue_draw</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>queue_draw</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Equivalent to calling <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-DRAW-AREA"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_draw_area()</TT
></A
> for the
entire area of a widget.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--QUEUE-DRAW-AREA"
>GtkWidget.queue_draw_area</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>queue_draw_area</B
></CODE
>(<VAR
CLASS="PDPARAM"
>x</VAR
>, <VAR
CLASS="PDPARAM"
>y</VAR
>, <VAR
CLASS="PDPARAM"
>width</VAR
>, <VAR
CLASS="PDPARAM"
>height</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>x</I
></TT
></DT
><DD
><P
>x coordinate of upper-left corner of rectangle to redraw</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>y</I
></TT
></DT
><DD
><P
>y coordinate of upper-left corner of rectangle to redraw</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>width</I
></TT
></DT
><DD
><P
>width of region to draw</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>height</I
></TT
></DT
><DD
><P
>height of region to draw</P
></DD
></DL
></DIV
><P
>Invalidates the rectangular area of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> defined by <TT
CLASS="PARAMETER"
><I
>x</I
></TT
>, <TT
CLASS="PARAMETER"
><I
>y</I
></TT
>,
<TT
CLASS="PARAMETER"
><I
>width</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>height</I
></TT
> by calling <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-RECT"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_rect()</TT
></A
> on the
widget's window and all its child windows.  Once the main loop
becomes idle (after the current batch of events has been processed,
roughly), the window will receive expose events for the union of
all regions that have been invalidated.</P
><P
>Normally you would only use this function in widget
implementations. You might also use it, or
<A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-RECT"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_rect()</TT
></A
> directly, to schedule a redraw of a
<A
HREF="class-gtkdrawingarea.html"
><SPAN
CLASS="TYPE"
>GtkDrawingArea</SPAN
></A
> or some portion thereof.</P
><P
>Frequently you can just call <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-RECT"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_rect()</TT
></A
> or
<A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-REGION"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_region()</TT
></A
> instead of this function. Those
functions will invalidate only a single window, instead of the
widget and all its children.</P
><P
>The advantage of adding to the invalidated region compared to
simply drawing immediately is efficiency; using an invalid region
ensures that you only have to redraw one time.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--QUEUE-CLEAR"
>GtkWidget.queue_clear</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>queue_clear</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>DEPRECATED. Use <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-DRAW"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_draw()</TT
></A
> instead.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--QUEUE-CLEAR-AREA"
>GtkWidget.queue_clear_area</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>queue_clear_area</B
></CODE
>(<VAR
CLASS="PDPARAM"
>x</VAR
>, <VAR
CLASS="PDPARAM"
>y</VAR
>, <VAR
CLASS="PDPARAM"
>width</VAR
>, <VAR
CLASS="PDPARAM"
>height</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>x</I
></TT
></DT
><DD
><P
>x coordinate of upper-left corner of rectangle to redraw</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>y</I
></TT
></DT
><DD
><P
>y coordinate of upper-left corner of rectangle to redraw</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>width</I
></TT
></DT
><DD
><P
>width of region to draw</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>height</I
></TT
></DT
><DD
><P
>height of region to draw</P
></DD
></DL
></DIV
><P
>DEPRECATED. This function is no longer different from
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-DRAW-AREA"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_draw_area()</TT
></A
>, though it once was. Now it just calls
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-DRAW-AREA"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_draw_area()</TT
></A
>. Originally
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-CLEAR-AREA"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_clear_area()</TT
></A
> would force a redraw of the
background for GTK_NO_WINDOW widgets, and
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-DRAW-AREA"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_draw_area()</TT
></A
> would not. Now both functions ensure
the background will be redrawn.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--QUEUE-RESIZE"
>GtkWidget.queue_resize</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>queue_resize</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>This function is only for use in widget implementations.
Flags a widget to have its size renegotiated; should
be called when a widget for some reason has a new size request.
For example, when you change the text in a <A
HREF="class-gtklabel.html"
><SPAN
CLASS="TYPE"
>GtkLabel</SPAN
></A
>, <A
HREF="class-gtklabel.html"
><SPAN
CLASS="TYPE"
>GtkLabel</SPAN
></A
>
queues a resize to ensure there's enough space for the new text.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--DRAW"
>GtkWidget.draw</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>draw</B
></CODE
>(<VAR
CLASS="PDPARAM"
>area</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>area</I
></TT
></DT
><DD
><P
>area to draw</P
></DD
></DL
></DIV
><P
>DEPRECATED. In GTK+ 1.2, this function would immediately render the
region <TT
CLASS="PARAMETER"
><I
>area</I
></TT
> of a widget, by invoking the virtual draw method of a
widget. In GTK+ 2.0, the draw method is gone, and instead
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--DRAW"
><TT
CLASS="FUNCTION"
>GtkWidget.draw()</TT
></A
> simply invalidates the specified region of the
widget, then updates the invalid region of the widget immediately.
Usually you don't want to update the region immediately for
performance reasons, so in general <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--QUEUE-DRAW-AREA"
><TT
CLASS="FUNCTION"
>GtkWidget.queue_draw_area()</TT
></A
> is
a better choice if you want to draw a region of a widget.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SIZE-REQUEST"
>GtkWidget.size_request</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>size_request</B
></CODE
>(<VAR
CLASS="PDPARAM"
>requisition</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>requisition</I
></TT
></DT
><DD
><P
>a <TT
CLASS="LITERAL"
>GtkRequisition</TT
> to be filled in</P
></DD
></DL
></DIV
><P
>This function is only used when implementing a <A
HREF="class-gtkcontainer.html"
><SPAN
CLASS="TYPE"
>GtkContainer</SPAN
></A
> subclass.
Obtains the preferred size of a widget. The container uses this
information to arrange its child widgets and decide what size allocations
to give them with <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SIZE-ALLOCATE"
><TT
CLASS="FUNCTION"
>GtkWidget.size_allocate()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SIZE-ALLOCATE"
>GtkWidget.size_allocate</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>size_allocate</B
></CODE
>(<VAR
CLASS="PDPARAM"
>allocation</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>allocation</I
></TT
></DT
><DD
><P
>position and size to be allocated to <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>This function is only used by <A
HREF="class-gtkcontainer.html"
><SPAN
CLASS="TYPE"
>GtkContainer</SPAN
></A
> subclasses, to assign a size
and position to their child widgets.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-CHILD-REQUISITION"
>GtkWidget.get_child_requisition</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_child_requisition</B
></CODE
>(<VAR
CLASS="PDPARAM"
>requisition</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>requisition</I
></TT
></DT
><DD
><P
>a <TT
CLASS="LITERAL"
>GtkRequisition</TT
> to be filled in</P
></DD
></DL
></DIV
><P
>This function is only for use in widget implementations. Obtains
<TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>-&#62;requisition, unless someone has forced a particular
geometry on the widget (e.g. with <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-USIZE"
><TT
CLASS="FUNCTION"
>GtkWidget.set_usize()</TT
></A
>), in which
case it returns that geometry instead of the widget's requisition.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--ADD-ACCELERATOR"
>GtkWidget.add_accelerator</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>add_accelerator</B
></CODE
>(<VAR
CLASS="PDPARAM"
>accel_signal</VAR
>, <VAR
CLASS="PDPARAM"
>accel_group</VAR
>, <VAR
CLASS="PDPARAM"
>accel_key</VAR
>, <VAR
CLASS="PDPARAM"
>accel_mods</VAR
>, <VAR
CLASS="PDPARAM"
>accel_flags</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>accel_signal</I
></TT
></DT
><DD
><P
>a const-gchar*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_group</I
></TT
></DT
><DD
><P
>a GtkAccelGroup*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_key</I
></TT
></DT
><DD
><P
>a guint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_mods</I
></TT
></DT
><DD
><P
>a guint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_flags</I
></TT
></DT
><DD
><P
>a GtkAccelFlags</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--REMOVE-ACCELERATOR"
>GtkWidget.remove_accelerator</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>remove_accelerator</B
></CODE
>(<VAR
CLASS="PDPARAM"
>accel_group</VAR
>, <VAR
CLASS="PDPARAM"
>accel_key</VAR
>, <VAR
CLASS="PDPARAM"
>accel_mods</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>accel_group</I
></TT
></DT
><DD
><P
>a GtkAccelGroup*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_key</I
></TT
></DT
><DD
><P
>a guint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_mods</I
></TT
></DT
><DD
><P
>a guint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--REMOVE-ACCELERATORS"
>GtkWidget.remove_accelerators</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>remove_accelerators</B
></CODE
>(<VAR
CLASS="PDPARAM"
>accel_signal</VAR
>, <VAR
CLASS="PDPARAM"
>visible_only</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>accel_signal</I
></TT
></DT
><DD
><P
>a const-gchar*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>visible_only</I
></TT
></DT
><DD
><P
>a gboolean</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--ACCELERATOR-SIGNAL"
>GtkWidget.accelerator_signal</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>accelerator_signal</B
></CODE
>(<VAR
CLASS="PDPARAM"
>accel_group</VAR
>, <VAR
CLASS="PDPARAM"
>accel_key</VAR
>, <VAR
CLASS="PDPARAM"
>accel_mods</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>accel_group</I
></TT
></DT
><DD
><P
>a GtkAccelGroup*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_key</I
></TT
></DT
><DD
><P
>a guint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>accel_mods</I
></TT
></DT
><DD
><P
>a guint</P
></DD
><DT
>Returns:</DT
><DD
><P
>a guint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--LOCK-ACCELERATORS"
>GtkWidget.lock_accelerators</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>lock_accelerators</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--UNLOCK-ACCELERATORS"
>GtkWidget.unlock_accelerators</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>unlock_accelerators</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--ACCELERATORS-LOCKED"
>GtkWidget.accelerators_locked</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>accelerators_locked</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>a gboolean</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MNEMONIC-ACTIVATE"
>GtkWidget.mnemonic_activate</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>mnemonic_activate</B
></CODE
>(<VAR
CLASS="PDPARAM"
>group_cycling</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>group_cycling</I
></TT
></DT
><DD
><P
>a gboolean</P
></DD
><DT
>Returns:</DT
><DD
><P
>a gboolean</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--EVENT"
>GtkWidget.event</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>event</B
></CODE
>(<VAR
CLASS="PDPARAM"
>event</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>event</I
></TT
></DT
><DD
><P
>a <TT
CLASS="LITERAL"
>GdkEvent</TT
></P
></DD
><DT
>Returns:</DT
><DD
><P
>return from the event signal emission (<TT
CLASS="LITERAL"
>TRUE</TT
> if the event was handled)</P
></DD
></DL
></DIV
><P
>Rarely-used function. This function is used to emit
the event signals on a widget (those signals should never
be emitted without using this function to do so).
If you want to synthesize an event though, don't use this function;
instead, use <TT
CLASS="FUNCTION"
>main_do_event()</TT
> so the event will behave as if
it were in the event queue. Don't synthesize expose events; instead,
use <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-RECT"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_rect()</TT
></A
> to invalidate a region of the
window.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SEND-EXPOSE"
>GtkWidget.send_expose</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>send_expose</B
></CODE
>(<VAR
CLASS="PDPARAM"
>event</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>event</I
></TT
></DT
><DD
><P
>a expose <TT
CLASS="LITERAL"
>GdkEvent</TT
></P
></DD
><DT
>Returns:</DT
><DD
><P
>return from the event signal emission (<TT
CLASS="LITERAL"
>TRUE</TT
> if the event was handled)</P
></DD
></DL
></DIV
><P
>Very rarely-used function. This function is used to emit
an expose event signals on a widget. This function is not
normally used directly. The only time it is used is when
propagating an expose event to a child NO_WINDOW widget, and
that is normally done using gtk_container_propagate_expose.</P
><P
>If you want to force an area of a window to be redrawn, 
use <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-RECT"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_rect()</TT
></A
> or <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INVALIDATE-REGION"
><TT
CLASS="FUNCTION"
>GdkWindow.invalidate_region()</TT
></A
>.
To cause the redraw to be done immediately, follow that call
with a call to <TT
CLASS="FUNCTION"
>gdk_window_procss_updates()</TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--ACTIVATE"
>GtkWidget.activate</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>activate</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if the widget was activatable</P
></DD
></DL
></DIV
><P
>For widgets that can be "activated" (buttons, menu items, etc.)
this function activates them. Activation is what happens when you
press Enter on a widget during key navigation; clicking a button,
selecting a menu item, etc. If <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> isn't activatable,
the function returns <TT
CLASS="LITERAL"
>FALSE</TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-SCROLL-ADJUSTMENTS"
>GtkWidget.set_scroll_adjustments</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_scroll_adjustments</B
></CODE
>(<VAR
CLASS="PDPARAM"
>hadjustment</VAR
>, <VAR
CLASS="PDPARAM"
>vadjustment</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>hadjustment</I
></TT
></DT
><DD
><P
>an adjustment for horizontal scrolling, or <TT
CLASS="LITERAL"
>NULL</TT
></P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>vadjustment</I
></TT
></DT
><DD
><P
>an adjustment for vertical scrolling, or <TT
CLASS="LITERAL"
>NULL</TT
></P
></DD
><DT
>Returns:</DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if the widget supports scrolling</P
></DD
></DL
></DIV
><P
>For widgets that support scrolling, sets the scroll adjustments and
returns <TT
CLASS="LITERAL"
>TRUE</TT
>.  For widgets that don't support scrolling, does
nothing and returns <TT
CLASS="LITERAL"
>FALSE</TT
>. Widgets that don't support scrolling
can be scrolled by placing them in a <A
HREF="class-gtkviewport.html"
><SPAN
CLASS="TYPE"
>GtkViewport</SPAN
></A
>, which does
support scrolling.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--REPARENT"
>GtkWidget.reparent</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>reparent</B
></CODE
>(<VAR
CLASS="PDPARAM"
>new_parent</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>new_parent</I
></TT
></DT
><DD
><P
>a <A
HREF="class-gtkcontainer.html"
><SPAN
CLASS="TYPE"
>GtkContainer</SPAN
></A
> to move the widget into</P
></DD
></DL
></DIV
><P
>Moves a widget from one <A
HREF="class-gtkcontainer.html"
><SPAN
CLASS="TYPE"
>GtkContainer</SPAN
></A
> to another, handling reference
count issues to avoid destroying the widget.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--INTERSECT"
>GtkWidget.intersect</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>intersect</B
></CODE
>(<VAR
CLASS="PDPARAM"
>area</VAR
>, <VAR
CLASS="PDPARAM"
>intersection</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>area</I
></TT
></DT
><DD
><P
>a rectangle</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>intersection</I
></TT
></DT
><DD
><P
>rectangle to store intersection of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>area</I
></TT
></P
></DD
><DT
>Returns:</DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if there was an intersection</P
></DD
></DL
></DIV
><P
>Computes the intersection of a <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>'s area and <TT
CLASS="PARAMETER"
><I
>area</I
></TT
>, storing
the intersection in <TT
CLASS="PARAMETER"
><I
>intersection</I
></TT
>, and returns <TT
CLASS="LITERAL"
>TRUE</TT
> if there was
an intersection.  <TT
CLASS="PARAMETER"
><I
>intersection</I
></TT
> may be <TT
CLASS="LITERAL"
>NULL</TT
> if you're only
interested in whether there was an intersection.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--REGION-INTERSECT"
>GtkWidget.region_intersect</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>region_intersect</B
></CODE
>(<VAR
CLASS="PDPARAM"
>region</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>region</I
></TT
></DT
><DD
><P
>a <TT
CLASS="LITERAL"
>GdkRegion</TT
>, in the same coordinate system as 
widget-&#62;allocation. That is, relative to widget-&#62;window
for NO_WINDOW widgets; relative to the parent window
of widget-&#62;window for widgets with their own window.</P
></DD
><DT
>Returns:</DT
><DD
><P
>a GdkRegion*</P
></DD
></DL
></DIV
><P
>Computes the intersection of a <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>'s area and <TT
CLASS="PARAMETER"
><I
>region</I
></TT
>, returning
the intersection. The result may be empty, use <TT
CLASS="LITERAL"
>gdk_region_empty</TT
> to
check.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--IS-FOCUS"
>GtkWidget.is_focus</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>is_focus</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if the widget is the focus widget.</P
></DD
></DL
></DIV
><P
>Determines if the widget is the focus widget within its
toplevel. (This does not mean that the HAS_FOCUS flag is
necessarily set; HAS_FOCUS will only be set if the
toplevel widget additionally has the global input focus.)</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GRAB-FOCUS"
>GtkWidget.grab_focus</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>grab_focus</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Causes <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> to have the keyboard focus for the <A
HREF="class-gtkwindow.html"
><SPAN
CLASS="TYPE"
>GtkWindow</SPAN
></A
> it's
inside. <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> must be a focusable widget, such as a <A
HREF="class-gtkentry.html"
><SPAN
CLASS="TYPE"
>GtkEntry</SPAN
></A
>;
something like <A
HREF="class-gtkframe.html"
><SPAN
CLASS="TYPE"
>GtkFrame</SPAN
></A
> won't work. (More precisely, it must have the
<TT
CLASS="LITERAL"
>GTK_CAN_FOCUS</TT
> flag set.)</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GRAB-DEFAULT"
>GtkWidget.grab_default</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>grab_default</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Causes <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> to become the default widget. <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> must have the
<TT
CLASS="LITERAL"
>GTK_CAN_DEFAULT</TT
> flag set; typically you have to set this flag
yourself by calling GTK_WIDGET_SET_FLAGS (<TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>,
GTK_CAN_DEFAULT).  The default widget is activated when the user
presses Enter in a window.  Default widgets must be activatable,
that is, <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--ACTIVATE"
><TT
CLASS="FUNCTION"
>GtkWidget.activate()</TT
></A
> should affect them.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-NAME"
>GtkWidget.set_name</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_name</B
></CODE
>(<VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
></DT
><DD
><P
>name for the widget</P
></DD
></DL
></DIV
><P
>Widgets can be named, which allows you to refer to them from a
gtkrc file. You can apply a style to widgets with a particular name
in the gtkrc file. See the documentation for gtkrc files (on the
same page as the docs for <A
HREF="class-gtkrcstyle.html"
><SPAN
CLASS="TYPE"
>GtkRcStyle</SPAN
></A
>).</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-NAME"
>GtkWidget.get_name</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_name</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>name of the widget</P
></DD
></DL
></DIV
><P
>Retrieves the name of a widget. The return value should not be
freed. See <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-NAME"
><TT
CLASS="FUNCTION"
>GtkWidget.set_name()</TT
></A
> for the significance of widget
names.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-STATE"
>GtkWidget.set_state</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_state</B
></CODE
>(<VAR
CLASS="PDPARAM"
>state</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>state</I
></TT
></DT
><DD
><P
>new state for <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>This function is for use in widget implementations. Sets the state
of a widget (insensitive, prelighted, etc.) Usually you should set
the state using wrapper functions such as <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-SENSITIVE"
><TT
CLASS="FUNCTION"
>GtkWidget.set_sensitive()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-SENSITIVE"
>GtkWidget.set_sensitive</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_sensitive</B
></CODE
>(<VAR
CLASS="PDPARAM"
>sensitive</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>sensitive</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> to make the widget sensitive</P
></DD
></DL
></DIV
><P
>Sets the sensitivity of a widget. A widget is sensitive if the user
can interact with it. Insensitive widgets are "grayed out" and the
user can't interact with them. Insensitive widgets are known as
"inactive" in some other toolkits.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-APP-PAINTABLE"
>GtkWidget.set_app_paintable</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_app_paintable</B
></CODE
>(<VAR
CLASS="PDPARAM"
>app_paintable</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>app_paintable</I
></TT
></DT
><DD
><P
>a gboolean</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-DOUBLE-BUFFERED"
>GtkWidget.set_double_buffered</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_double_buffered</B
></CODE
>(<VAR
CLASS="PDPARAM"
>double_buffered</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>double_buffered</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> to double-buffer a widget</P
></DD
></DL
></DIV
><P
>Widgets are double buffered by default; you can use this function
to turn off the buffering. "Double buffered" simply means that
<TT
CLASS="FUNCTION"
>gdk_window_begin_paint()</TT
> and <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--END-PAINT"
><TT
CLASS="FUNCTION"
>GdkWindow.end_paint()</TT
></A
> are called
automatically around expose events sent to the
widget. <TT
CLASS="FUNCTION"
>gdk_window_begin_paint()</TT
> diverts all drawing to a widget's
window to an offscreen buffer, and <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--END-PAINT"
><TT
CLASS="FUNCTION"
>GdkWindow.end_paint()</TT
></A
> draws the
buffer to the screen. The result is that users see the window
update in one smooth step, and don't see individual graphics
primitives being rendered.</P
><P
>In very simple terms, double buffered widgets don't flicker,
so you would only use this function to turn off double buffering
if you had special needs and really knew what you were doing.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-PARENT"
>GtkWidget.set_parent</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_parent</B
></CODE
>(<VAR
CLASS="PDPARAM"
>parent</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>parent</I
></TT
></DT
><DD
><P
>parent container</P
></DD
></DL
></DIV
><P
>This function is useful only when implementing subclasses of <A
HREF="class-gtkcontainer.html"
><SPAN
CLASS="TYPE"
>GtkContainer</SPAN
></A
>.
Sets the container as the parent of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>, and takes care of
some details such as updating the state and style of the child
to reflect its new location. The opposite function is
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--UNPARENT"
><TT
CLASS="FUNCTION"
>GtkWidget.unparent()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-PARENT-WINDOW"
>GtkWidget.set_parent_window</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_parent_window</B
></CODE
>(<VAR
CLASS="PDPARAM"
>parent_window</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>parent_window</I
></TT
></DT
><DD
><P
>a GdkWindow*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-PARENT-WINDOW"
>GtkWidget.get_parent_window</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_parent_window</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>a GdkWindow*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-UPOSITION"
>GtkWidget.set_uposition</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_uposition</B
></CODE
>(<VAR
CLASS="PDPARAM"
>x</VAR
>, <VAR
CLASS="PDPARAM"
>y</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>x</I
></TT
></DT
><DD
><P
>x position; -1 to unset x; -2 to leave x unchanged</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>y</I
></TT
></DT
><DD
><P
>y position; -1 to unset y; -2 to leave y unchanged</P
></DD
></DL
></DIV
><P
>Sets the position of a widget. The funny "u" in the name comes from
the "user position" hint specified by the X window system, and
exists for legacy reasons. This function doesn't work if a widget
is inside a container; it's only really useful on <A
HREF="class-gtkwindow.html"
><SPAN
CLASS="TYPE"
>GtkWindow</SPAN
></A
>.</P
><P
>Don't use this function to center dialogs over the main application
window; most window managers will do the centering on your behalf
if you call <A
HREF="class-gtkwindow.html#METHOD-GTKWINDOW--SET-TRANSIENT-FOR"
><TT
CLASS="FUNCTION"
>GtkWindow.set_transient_for()</TT
></A
>, and it's really not
possible to get the centering to work correctly in all cases from
application code. But if you insist, use <A
HREF="class-gtkwindow.html#METHOD-GTKWINDOW--SET-POSITION"
><TT
CLASS="FUNCTION"
>GtkWindow.set_position()</TT
></A
>
to set <TT
CLASS="LITERAL"
>GTK_WIN_POS_CENTER_ON_PARENT</TT
>, don't do the centering
manually.</P
><P
>Note that although x and y can be individually unset, the position
is not honoured unless both x and y are set.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-USIZE"
>GtkWidget.set_usize</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_usize</B
></CODE
>(<VAR
CLASS="PDPARAM"
>width</VAR
>, <VAR
CLASS="PDPARAM"
>height</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>width</I
></TT
></DT
><DD
><P
>minimum width, or -1 to unset</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>height</I
></TT
></DT
><DD
><P
>minimum height, or -1 to unset</P
></DD
></DL
></DIV
><P
>Sets the minimum size of a widget; that is, the widget's size
request will be <TT
CLASS="PARAMETER"
><I
>width</I
></TT
> by <TT
CLASS="PARAMETER"
><I
>height</I
></TT
>. You can use this function to
force a widget to be either larger or smaller than it is. The
strange "usize" name dates from the early days of GTK+, and derives
from X Window System terminology. In many cases,
<A
HREF="class-gtkwindow.html#METHOD-GTKWINDOW--SET-DEFAULT-SIZE"
><TT
CLASS="FUNCTION"
>GtkWindow.set_default_size()</TT
></A
> is a better choice for toplevel
windows than this function; setting the default size will still
allow users to shrink the window. Setting the usize will force them
to leave the window at least as large as the usize. When dealing
with window sizes, <A
HREF="class-gtkwindow.html#METHOD-GTKWINDOW--SET-GEOMETRY-HINTS"
><TT
CLASS="FUNCTION"
>GtkWindow.set_geometry_hints()</TT
></A
> can be a useful
function as well.</P
><P
>Note the inherent danger of setting any fixed size - themes,
translations into other languages, different fonts, and user action
can all change the appropriate size for a given widget. So, it's
basically impossible to hardcode a size that will always be
correct.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-EVENTS"
>GtkWidget.set_events</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_events</B
></CODE
>(<VAR
CLASS="PDPARAM"
>events</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>events</I
></TT
></DT
><DD
><P
>event mask</P
></DD
></DL
></DIV
><P
>Sets the event mask (see <TT
CLASS="LITERAL"
>GdkEventMask</TT
>) for a widget. The event
mask determines which events a widget will receive. Keep in mind
that different widgets have different default event masks, and by
changing the event mask you may disrupt a widget's functionality,
so be careful. This function must be called while a widget is
unrealized. Consider <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--ADD-EVENTS"
><TT
CLASS="FUNCTION"
>GtkWidget.add_events()</TT
></A
> for widgets that are
already realized, or if you want to preserve the existing event
mask. This function can't be used with <TT
CLASS="LITERAL"
>GTK_NO_WINDOW</TT
> widgets;
to get events on those widgets, place them inside a <A
HREF="class-gtkeventbox.html"
><SPAN
CLASS="TYPE"
>GtkEventBox</SPAN
></A
>
and receive events on the event box.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--ADD-EVENTS"
>GtkWidget.add_events</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>add_events</B
></CODE
>(<VAR
CLASS="PDPARAM"
>events</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>events</I
></TT
></DT
><DD
><P
>an event mask, see <TT
CLASS="LITERAL"
>GdkEventMask</TT
></P
></DD
></DL
></DIV
><P
>Adds the events in the bitfield <TT
CLASS="PARAMETER"
><I
>events</I
></TT
> to the event mask for
<TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>. See <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-EVENTS"
><TT
CLASS="FUNCTION"
>GtkWidget.set_events()</TT
></A
> for details.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-EXTENSION-EVENTS"
>GtkWidget.set_extension_events</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_extension_events</B
></CODE
>(<VAR
CLASS="PDPARAM"
>mode</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>mode</I
></TT
></DT
><DD
><P
>bitfield of extension events to receive</P
></DD
></DL
></DIV
><P
>Sets the extension events mask to <TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>. See <TT
CLASS="LITERAL"
>GdkExtensionMode</TT
>
and <A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INPUT-SET-EXTENSION-EVENTS"
><TT
CLASS="FUNCTION"
>GdkWindow.input_set_extension_events()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-EXTENSION-EVENTS"
>GtkWidget.get_extension_events</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_extension_events</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>extension events for <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>Retrieves the extension events the widget will receive; see
<A
HREF="class-gdkwindow.html#METHOD-GDKWINDOW--INPUT-SET-EXTENSION-EVENTS"
><TT
CLASS="FUNCTION"
>GdkWindow.input_set_extension_events()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-TOPLEVEL"
>GtkWidget.get_toplevel</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_toplevel</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the topmost ancestor of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>, or <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> itself if there's no ancestor</P
></DD
></DL
></DIV
><P
>This function returns the topmost widget in the container hierarchy
<TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> is a part of. If <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> has no parent widgets, it will be
returned as the topmost widget. No reference will be added to the
returned widget; it should not be unreferenced.</P
><P
>Note the difference in behavior vs. <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--GET-ANCESTOR"
><TT
CLASS="FUNCTION"
>GtkWidget.get_ancestor()</TT
></A
>;
gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW) would return
<TT
CLASS="LITERAL"
>NULL</TT
> if <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> wasn't inside a toplevel window.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-ANCESTOR"
>GtkWidget.get_ancestor</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_ancestor</B
></CODE
>(<VAR
CLASS="PDPARAM"
>widget_type</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>widget_type</I
></TT
></DT
><DD
><P
>ancestor type</P
></DD
><DT
>Returns:</DT
><DD
><P
>the ancestor widget, or <TT
CLASS="LITERAL"
>NULL</TT
> if not found</P
></DD
></DL
></DIV
><P
>Gets the first ancestor of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> with type <TT
CLASS="PARAMETER"
><I
>widget_type</I
></TT
>. For example,
gtk_widget_get_ancestor (widget, GTK_TYPE_BOX) gets the first <A
HREF="class-gtkbox.html"
><SPAN
CLASS="TYPE"
>GtkBox</SPAN
></A
> that's
an ancestor of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>. No reference will be added to the returned widget;
it should not be unreferenced.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-COLORMAP"
>GtkWidget.get_colormap</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_colormap</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the colormap used by <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>Gets the colormap that will be used to render <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>. No reference will
be added to the returned colormap; it should not be unreferenced.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-VISUAL"
>GtkWidget.get_visual</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_visual</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the visual for <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>Gets the visual that will be used to render <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-COLORMAP"
>GtkWidget.set_colormap</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_colormap</B
></CODE
>(<VAR
CLASS="PDPARAM"
>colormap</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>colormap</I
></TT
></DT
><DD
><P
>a colormap</P
></DD
></DL
></DIV
><P
>Set the colormap for the widget to the given value. Widget must not
have been previously realized. This probably should only be used
from an <TT
CLASS="FUNCTION"
>init()</TT
> function (i.e. from the constructor for the widget).</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-EVENTS"
>GtkWidget.get_events</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_events</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>event mask for <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
></P
></DD
></DL
></DIV
><P
>Returns the event mask for the widget (a bitfield containing flags
from the <TT
CLASS="LITERAL"
>GdkEventMask</TT
> enumeration). These are the events that the widget
will receive.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-POINTER"
>GtkWidget.get_pointer</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_pointer</B
></CODE
>(<VAR
CLASS="PDPARAM"
>x</VAR
>, <VAR
CLASS="PDPARAM"
>y</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>x</I
></TT
></DT
><DD
><P
>return location for the X coordinate, or <TT
CLASS="LITERAL"
>NULL</TT
></P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>y</I
></TT
></DT
><DD
><P
>return location for the Y coordinate, or <TT
CLASS="LITERAL"
>NULL</TT
></P
></DD
></DL
></DIV
><P
>Obtains the location of the mouse pointer in widget coordinates.
Widget coordinates are a bit odd; for historical reasons, they are
defined as widget-&#62;window coordinates for widgets that are not
<TT
CLASS="LITERAL"
>GTK_NO_WINDOW</TT
> widgets, and are relative to widget-&#62;allocation.x,
widget-&#62;allocation.y for widgets that are <TT
CLASS="LITERAL"
>GTK_NO_WINDOW</TT
> widgets.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--IS-ANCESTOR"
>GtkWidget.is_ancestor</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>is_ancestor</B
></CODE
>(<VAR
CLASS="PDPARAM"
>ancestor</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>ancestor</I
></TT
></DT
><DD
><P
>another <A
HREF="class-gtkwidget.html"
><SPAN
CLASS="TYPE"
>GtkWidget</SPAN
></A
></P
></DD
><DT
>Returns:</DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>ancestor</I
></TT
> contains <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> as a child, grandchild, great grandchild, etc.</P
></DD
></DL
></DIV
><P
>Determines whether <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> is somewhere inside <TT
CLASS="PARAMETER"
><I
>ancestor</I
></TT
>, possibly with
intermediate containers.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--HIDE-ON-DELETE"
>GtkWidget.hide_on_delete</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>hide_on_delete</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
><TT
CLASS="LITERAL"
>TRUE</TT
></P
></DD
></DL
></DIV
><P
>Utility function; intended to be connected to the "delete_event"
signal on a <A
HREF="class-gtkwindow.html"
><SPAN
CLASS="TYPE"
>GtkWindow</SPAN
></A
>. The function calls <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--HIDE"
><TT
CLASS="FUNCTION"
>GtkWidget.hide()</TT
></A
> on its
argument, then returns <TT
CLASS="LITERAL"
>TRUE</TT
>. If connected to "delete_event",
the result is that clicking the window manager close button for
will hide but not destroy the window. By default, GTK+ destroys
windows when "delete_event" is received.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-STYLE"
>GtkWidget.set_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_style</B
></CODE
>(<VAR
CLASS="PDPARAM"
>style</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>style</I
></TT
></DT
><DD
><P
>a <A
HREF="class-gtkstyle.html"
><SPAN
CLASS="TYPE"
>GtkStyle</SPAN
></A
></P
></DD
></DL
></DIV
><P
>Sets the <A
HREF="class-gtkstyle.html"
><SPAN
CLASS="TYPE"
>GtkStyle</SPAN
></A
> for a widget (widget-&#62;style). You probably don't
want to use this function; it interacts badly with themes, because
themes work by replacing the <A
HREF="class-gtkstyle.html"
><SPAN
CLASS="TYPE"
>GtkStyle</SPAN
></A
>. Instead, use
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-RC-STYLE"
>GtkWidget.set_rc_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_rc_style</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><P
></P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--ENSURE-STYLE"
>GtkWidget.ensure_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>ensure_style</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
>Ensures that <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> has a style (widget-&#62;style). Not a very useful
function; most of the time, if you want the style, the widget is
realized, and realized widgets are guaranteed to have a style
already.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-STYLE"
>GtkWidget.get_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_style</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the widget's <A
HREF="class-gtkstyle.html"
><SPAN
CLASS="TYPE"
>GtkStyle</SPAN
></A
></P
></DD
></DL
></DIV
><P
>Simply an accessor function that returns widget-&#62;style.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--RESTORE-DEFAULT-STYLE"
>GtkWidget.restore_default_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>restore_default_style</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MODIFY-STYLE"
>GtkWidget.modify_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>modify_style</B
></CODE
>(<VAR
CLASS="PDPARAM"
>style</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>style</I
></TT
></DT
><DD
><P
>the <A
HREF="class-gtkrcstyle.html"
><SPAN
CLASS="TYPE"
>GtkRcStyle</SPAN
></A
> holding the style modifications</P
></DD
></DL
></DIV
><P
>Modify style values on the widget. Modifications made using this
technique take precendence over style values set via an RC file,
however, they will be overriden if a style is explicitely set on
the widget using <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.set_style()</TT
></A
>. The <A
HREF="class-gtkrcstyle.html"
><SPAN
CLASS="TYPE"
>GtkRcStyle</SPAN
></A
> structure
is designed so each field can either be set or unset, so it is
possible, using this function, to modify some style values and
leave the others unchanged.</P
><P
>Note that modifications made with this function are not cumulative
with previous calls to <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
> or with such
functions as <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-FG"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_fg()</TT
></A
>. If you wish to retain
previous values, you must first call <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--GET-MODIFIER-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.get_modifier_style()</TT
></A
>,
make your modifications to the returned style, then call
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
> with that style. On the other hand,
if you first call <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>, subsequent calls
to such functions <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-FG"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_fg()</TT
></A
> will be have a cumulative
effect with the inital modifications.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-MODIFIER-STYLE"
>GtkWidget.get_modifier_style</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_modifier_style</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the modifier style for the widget. This rc style is
owned by the widget. If you want to keep a pointer to value this
around, you must add a refcount using <A
HREF="class-gtkrcstyle.html#METHOD-GTKRCSTYLE--REF"
><TT
CLASS="FUNCTION"
>GtkRcStyle.ref()</TT
></A
>.</P
></DD
></DL
></DIV
><P
>Return the current modifier style for the widget. (As set by
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>.) If no style has previously set, a new
<A
HREF="class-gtkrcstyle.html"
><SPAN
CLASS="TYPE"
>GtkRcStyle</SPAN
></A
> will be created with all values unset, and set as the
modifier style for the widget. If you make changes to this rc
style, you must call <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>, passing in the
returned rc style, to make sure that your changes take effect.</P
><P
>Caution: passing the style back to <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
> will
normally end up destroying it, because <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
> copies
the passed-in style and sets the copy as the new modifier style,
thus dropping any reference to the old modifier style. Add a reference
to the modifier style if you want to keep it alive.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MODIFY-FG"
>GtkWidget.modify_fg</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>modify_fg</B
></CODE
>(<VAR
CLASS="PDPARAM"
>state</VAR
>, <VAR
CLASS="PDPARAM"
>color</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>state</I
></TT
></DT
><DD
><P
>the state for which to set the foreground color.</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>color</I
></TT
></DT
><DD
><P
>the color to assign (does not need to be allocated)</P
></DD
></DL
></DIV
><P
>Set the foreground color for a widget in a particular state.  All
other style values are left untouched. See also
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MODIFY-BG"
>GtkWidget.modify_bg</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>modify_bg</B
></CODE
>(<VAR
CLASS="PDPARAM"
>state</VAR
>, <VAR
CLASS="PDPARAM"
>color</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>state</I
></TT
></DT
><DD
><P
>the state for which to set the foreground color.</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>color</I
></TT
></DT
><DD
><P
>the color to assign (does not need to be allocated)</P
></DD
></DL
></DIV
><P
>Set the background color for a widget in a particular state.  All
other style values are left untouched. See also
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MODIFY-TEXT"
>GtkWidget.modify_text</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>modify_text</B
></CODE
>(<VAR
CLASS="PDPARAM"
>state</VAR
>, <VAR
CLASS="PDPARAM"
>color</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>state</I
></TT
></DT
><DD
><P
>a GtkStateType</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>color</I
></TT
></DT
><DD
><P
>a GdkColor*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MODIFY-BASE"
>GtkWidget.modify_base</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>modify_base</B
></CODE
>(<VAR
CLASS="PDPARAM"
>state</VAR
>, <VAR
CLASS="PDPARAM"
>color</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>state</I
></TT
></DT
><DD
><P
>the state for which to set the foreground color.</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>color</I
></TT
></DT
><DD
><P
>the color to assign (does not need to be allocated)</P
></DD
></DL
></DIV
><P
>Set the text color for a widget in a particular state.
All other style values are left untouched. The base color
is the background color used along with the text color
(see gtk_widget_modify_text) for widgets such as <A
HREF="class-gtkentry.html"
><SPAN
CLASS="TYPE"
>GtkEntry</SPAN
></A
>
and <A
HREF="class-gtktextview.html"
><SPAN
CLASS="TYPE"
>GtkTextView</SPAN
></A
>. See also <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--MODIFY-FONT"
>GtkWidget.modify_font</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>modify_font</B
></CODE
>(<VAR
CLASS="PDPARAM"
>font_desc</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>font_desc</I
></TT
></DT
><DD
><P
>the font description to use</P
></DD
></DL
></DIV
><P
>Set the font to use for a widget.  All other style values are left
untouched. See also <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--MODIFY-STYLE"
><TT
CLASS="FUNCTION"
>GtkWidget.modify_style()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--CREATE-PANGO-CONTEXT"
>GtkWidget.create_pango_context</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>create_pango_context</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the new <TT
CLASS="LITERAL"
>PangoContext</TT
></P
></DD
></DL
></DIV
><P
>Create a new pango context with the appropriate colormap,
font description, and base direction for drawing text for
this widget. See also <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--GET-PANGO-CONTEXT"
><TT
CLASS="FUNCTION"
>GtkWidget.get_pango_context()</TT
></A
></P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-PANGO-CONTEXT"
>GtkWidget.get_pango_context</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_pango_context</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the <TT
CLASS="LITERAL"
>PangoContext</TT
> for the widget.</P
></DD
></DL
></DIV
><P
>Get a <TT
CLASS="LITERAL"
>PangoContext</TT
> with the appropriate colormap, font description
and base direction for this widget. Unlike the context returned
by <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--CREATE-PANGO-CONTEXT"
><TT
CLASS="FUNCTION"
>GtkWidget.create_pango_context()</TT
></A
>, this context is owned by
the widget (it can be used as long as widget exists), and will
be updated to match any changes to the widget's attributes.</P
><P
>If you create and keep a <TT
CLASS="LITERAL"
>PangoLayout</TT
> using this context, you must
deal with changes to the context by calling <TT
CLASS="FUNCTION"
>pango_layout_context_changed()</TT
>
on the layout in response to the ::style_set and ::direction_set signals
for the widget.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--CREATE-PANGO-LAYOUT"
>GtkWidget.create_pango_layout</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>create_pango_layout</B
></CODE
>(<VAR
CLASS="PDPARAM"
>text</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>text</I
></TT
></DT
><DD
><P
>text to set on the layout (can be <TT
CLASS="LITERAL"
>NULL</TT
>)</P
></DD
><DT
>Returns:</DT
><DD
><P
>the new <TT
CLASS="LITERAL"
>PangoLayout</TT
></P
></DD
></DL
></DIV
><P
>Create a new <TT
CLASS="LITERAL"
>PangoLayout</TT
> with the appropriate colormap,
font description, and base direction for drawing text for
this widget.</P
><P
>If you keep a <TT
CLASS="LITERAL"
>PangoLayout</TT
> created in this way around, in order
notify the layout of changes to the base direction or font of this
widget, you must call <TT
CLASS="FUNCTION"
>pango_layout_context_changed()</TT
> in response to
the ::style_set and ::direction_set signals for the widget.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--RENDER-ICON"
>GtkWidget.render_icon</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>render_icon</B
></CODE
>(<VAR
CLASS="PDPARAM"
>stock_id</VAR
>, <VAR
CLASS="PDPARAM"
>size</VAR
>, <VAR
CLASS="PDPARAM"
>detail</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>stock_id</I
></TT
></DT
><DD
><P
>a stock ID</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
></DT
><DD
><P
>a stock size</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>detail</I
></TT
></DT
><DD
><P
>render detail to pass to theme engine</P
></DD
><DT
>Returns:</DT
><DD
><P
>a new pixbuf, or <TT
CLASS="LITERAL"
>NULL</TT
> if the stock ID wasn't known</P
></DD
></DL
></DIV
><P
>A convenience function that uses the theme engine and RC file
settings for <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
> to look up <TT
CLASS="PARAMETER"
><I
>stock_id</I
></TT
> and render it to
a pixbuf. <TT
CLASS="PARAMETER"
><I
>stock_id</I
></TT
> should be a stock icon ID such as
<TT
CLASS="LITERAL"
>GTK_STOCK_OPEN</TT
> or <TT
CLASS="LITERAL"
>GTK_STOCK_BUTTON_OK</TT
>. <TT
CLASS="PARAMETER"
><I
>size</I
></TT
> should be a size
such as <TT
CLASS="LITERAL"
>GTK_ICON_SIZE_MENU</TT
>. <TT
CLASS="PARAMETER"
><I
>detail</I
></TT
> should be a string that
identifies the widget or code doing the rendering, so that
theme engines can special-case rendering for that widget or code.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-COMPOSITE-NAME"
>GtkWidget.set_composite_name</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_composite_name</B
></CODE
>(<VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
></DT
><DD
><P
>a const-gchar*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-COMPOSITE-NAME"
>GtkWidget.get_composite_name</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_composite_name</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>a gchar*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--RESET-RC-STYLES"
>GtkWidget.reset_rc_styles</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>reset_rc_styles</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--STYLE-GET-PROPERTY"
>GtkWidget.style_get_property</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>style_get_property</B
></CODE
>(<VAR
CLASS="PDPARAM"
>property_name</VAR
>, <VAR
CLASS="PDPARAM"
>value</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>property_name</I
></TT
></DT
><DD
><P
>a const-gchar*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
></DT
><DD
><P
>a GValue*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--STYLE-GET-VALIST"
>GtkWidget.style_get_valist</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>style_get_valist</B
></CODE
>(<VAR
CLASS="PDPARAM"
>first_property_name</VAR
>, <VAR
CLASS="PDPARAM"
>var_args</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>first_property_name</I
></TT
></DT
><DD
><P
>a const-gchar*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>var_args</I
></TT
></DT
><DD
><P
>a va_list</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--STYLE-GET"
>GtkWidget.style_get</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>style_get</B
></CODE
>(<VAR
CLASS="PDPARAM"
>first_property_name</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>first_property_name</I
></TT
></DT
><DD
><P
>a const-gchar*</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SET-DIRECTION"
>GtkWidget.set_direction</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>set_direction</B
></CODE
>(<VAR
CLASS="PDPARAM"
>dir</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>dir</I
></TT
></DT
><DD
><P
>the new direction</P
></DD
></DL
></DIV
><P
>Set the reading direction on a particular widget. This direction
controls the primary direction for widgets containing text,
and also the direction in which the children of a container are
packed. The ability to set the direction is present in order
so that correct localization into languages with right-to-left
reading directions can be done. Generally, applications will
let the default reading direction present, except for containers
where the containers are arranged in an order that is explicitely
visual rather than logical (such as buttons for text justificiation).</P
><P
>If the direction is set to <TT
CLASS="LITERAL"
>GTK_TEXT_DIR_NONE</TT
>, then the value
set by <TT
CLASS="FUNCTION"
>widget_set_default_direction()</TT
> will be used.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--GET-DIRECTION"
>GtkWidget.get_direction</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>get_direction</B
></CODE
>();</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Returns:</DT
><DD
><P
>the reading direction for the widget.</P
></DD
></DL
></DIV
><P
>Get the reading direction for a particular widget. See
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-DIRECTION"
><TT
CLASS="FUNCTION"
>GtkWidget.set_direction()</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--SHAPE-COMBINE-MASK"
>GtkWidget.shape_combine_mask</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>shape_combine_mask</B
></CODE
>(<VAR
CLASS="PDPARAM"
>shape_mask</VAR
>, <VAR
CLASS="PDPARAM"
>offset_x</VAR
>, <VAR
CLASS="PDPARAM"
>offset_y</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>shape_mask</I
></TT
></DT
><DD
><P
>a GdkBitmap*</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>offset_x</I
></TT
></DT
><DD
><P
>a gint</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>offset_y</I
></TT
></DT
><DD
><P
>a gint</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--RESET-SHAPES"
>GtkWidget.reset_shapes</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>reset_shapes</B
></CODE
>();</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--PATH"
>GtkWidget.path</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>path</B
></CODE
>(<VAR
CLASS="PDPARAM"
>path_length</VAR
>, <VAR
CLASS="PDPARAM"
>path</VAR
>, <VAR
CLASS="PDPARAM"
>path_reversed</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>path_length</I
></TT
></DT
><DD
><P
>location to store length of the path</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>path</I
></TT
></DT
><DD
><P
>location to store allocated path string</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>path_reversed</I
></TT
></DT
><DD
><P
>location to store allocated reverse path string</P
></DD
></DL
></DIV
><P
>Obtains the full path to <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>. The path is simply the name of a
widget and all its parents in the container hierarchy, separated by
periods. The name of a widget comes from
<A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--GET-NAME"
><TT
CLASS="FUNCTION"
>GtkWidget.get_name()</TT
></A
>. Paths are used to apply styles to a widget
in gtkrc configuration files.  Widget names are the type of the
widget by default (e.g. "GtkButton") or can be set to an
application-specific value with <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-NAME"
><TT
CLASS="FUNCTION"
>GtkWidget.set_name()</TT
></A
>.  By setting
the name of a widget, you allow users or theme authors to apply
styles to that specific widget in their gtkrc
file. <TT
CLASS="PARAMETER"
><I
>path_reversed_p</I
></TT
> fills in the path in reverse order,
i.e. starting with <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>'s name instead of starting with the name
of <TT
CLASS="PARAMETER"
><I
>widget</I
></TT
>'s outermost ancestor.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="METHOD-GTKWIDGET--CLASS-PATH"
>GtkWidget.class_path</A
></H3
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
><TT
CLASS="REPLACEABLE"
><I
>instance</I
></TT
>.<B
CLASS="FSFUNC"
>class_path</B
></CODE
>(<VAR
CLASS="PDPARAM"
>path_length</VAR
>, <VAR
CLASS="PDPARAM"
>path</VAR
>, <VAR
CLASS="PDPARAM"
>path_reversed</VAR
>);</CODE
></P
><P
></P
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="PARAMETER"
><I
>path_length</I
></TT
></DT
><DD
><P
>location to store the length of the class path</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>path</I
></TT
></DT
><DD
><P
>location to store the class path as an allocated string</P
></DD
><DT
><TT
CLASS="PARAMETER"
><I
>path_reversed</I
></TT
></DT
><DD
><P
>location to store the reverse class path as an allocated string</P
></DD
></DL
></DIV
><P
>Same as <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--PATH"
><TT
CLASS="FUNCTION"
>GtkWidget.path()</TT
></A
>, but always uses the name of a widget's type,
never uses a custom name set with <A
HREF="class-gtkwidget.html#METHOD-GTKWIDGET--SET-NAME"
><TT
CLASS="FUNCTION"
>GtkWidget.set_name()</TT
></A
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="class-gtkviewport.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="class-gtkwindow.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Class GtkViewport</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Class GtkWindow</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>